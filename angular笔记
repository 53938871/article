.功能模块只需要导入:CommonModule，不需要导入BrowserModule
类也可以成接口使用，只要实现同样的方法就会被当成实现。 class A; class B implement A

.如果在Component中使用多态中的类，可以在@Component中使用Providers:[..],组件级别的provider. provider有2个级别，Component和Module.如果在component
中指定了一个service的子类，就使用providers:[{provide:父类名,useClass:子类名}]

providers:[{provide:xxx, useFactory:(isDev)=>{...}, deps:['常量名']}] ;deps就是useFactory所依赖的项，“常量名”会被当成isDev参数。如果要给“常量名”
赋值，就在@NgModule中的Providers中使用{provide:"常量名", useValue:"值"}; provide顺序，自己->父组件->Module

如果想确保一个特殊的可注入服务对子组件和其它组件不可见，可使用viewProviders替代Providers.

如果想让Angular知道绑定的是特性而不是(Dom属性)，需要加attr.前缀<input [attr.value]="greeting">

父类传子类时@Input，如果用[]表示绑定动态属性。如果是一个固定的值则不需要加[].<order [stock]="stock" num=100> stock就是动态的值,num是固定的。

@Output自定义事件的名称与输出属性的名称是一致的，也可以用别名.
子组件: let lastPrice: EmeitEvent = new EmeitEvent(); 要调用父组件的方法只需要调用 lastPrice.emit("值");
父组件： <parent (lastPrice)="父组件里的方法"></parent>
父子组件的lastPrice要一样，子组件的lasPrice属性要跟父组件的事件名称一样。

<ng-content></ng-content>
子组件：
selector: 'child',
template: `<div><h2>child</h2><ng-content></ng-content>`
父组件：
selector: 'app',
template: `<div><h2>parent</h2><child><div class='.header'>这是传给子组件的内容</div></child>`
父组件的template中有子组件选择器，那么父组件中的child中的内容将被传入子组件来替代<ng-content>中的内容。 可以有多个<ng-content>可以通过选择器来选择传
入的父组件的内容<ng-content select=".header"></ng-content>

父组件调用子组件,暴露子组件中的API.
<child #child1></child>
<child #child2></child>
只需要在父组件里声明一个变量，前用@ViewChild对其进行注解：
@ViewChild('child1')
firstChild: ChildComponent;
然后就可以调用子组件的方法了。<button (click)="child1.greet('xxx')">send</button>



模板驱动表单有3个主要的指令:NgModel, NgModelGroup,NgForm
NgForm表示整个表单的指令，它会自动附加到每个<form>元素，NgForm隐式的创建FormGroup类的一个实例。NgForm有多个选择器，可用于将NgForm附加到非<form>元素：
<div ngForm></div> 属性选择器; <ngForm></ngForm>元素选择器
如果要排除特定的<form>，使其不被Angular处理，请使用ngNoForm属性。可以创建一个引用NgForm实例的本地变量<form #f="ngForm"></form>  <pre>{{f.value | json}} <pre>
将ngModel添加到元素时，需要使用name属性 <input type="text" name="userName" ngModel /> 也可以创建一个引用变量<input type="text" name="userName" #c="ngModel" />
{{c.value}}; 
<form #f="ngForm" (ngSubmit)="onSubmit(f.value)">
   <div ngModelGroup="fullName"> //ngModelGroup属性需要一个字符串值，它将成为属性名称，表示带有子字段值的嵌套的fullName
   <input type="text" name="firstName" ngModel>
   <input type="text" name="lastName" ngModel>
   </div>
</form>
<pre>First Name: {{ f.value.fullname.firstName }}



响应式表单:FormGroup, FormControl, FromArray(多个同名的)
FormGroup->formGroupName; FormControl->formControlName; FormArray->formArrayName;
formGroup表示整个表单 <form [formGroup]="fromModel"></form>
formGroup可以嵌套formGroup
<form [formGropu]="formModel">
  <div formGroupName="dateRange">
     <input type="date" formControlName="from">
	 <input type="date" fromControlName="to">
  </div>
</form>

formModel: FormGroup = new FormGroup({
   emails: new FormArray([ //创建一个将表示整个表单的FormGroup
       new FormControl() //为email集合使用FormArray,允许用户输入多个电子邮件
	 ])
   });

   
this.formModel = new FormGroup({
   'userName': new FormControl(),
   'ssn': new FormControl(),
   'passwordsGroup': new FormGroup({
      'password': new FormControl(),
	  'pconfirm': new FormControl()
	})
   });
 }
 
使用FormBuilder更方便：
constructor(fb: FormBuilder) {
   this.formModel = fb.group({
      'userName': [''],
	  'ssn': [''],
	  'passwordsGrop': fb.group({ //与FromGroup一样，FormBuilder允许创建嵌套组;FormBuilder.group()
	      'password': [''], //方法接受具有额外配置参数的对象作为最后一个参数。可以用它来指定组验证器。
		  'pconfirm': ['']
	  })
   });
} 
